open System

// The banana clips (|...|) -> Active Pattern
// The banana clips with wildcard (|...|_|) -> Partial Active Pattern
let (|ValidDate|_|) (input: string) =
    match DateTime.TryParse(input) with
    | true, value -> Some value
    | false, _ -> None

let (|IsValidDate|_|) (input: string) =
    let success, _ = DateTime.TryParse input
    if success then Some() else None

let isValidDate input =
    match input with
    | IsValidDate -> true
    | _ -> false

let parse input =
    match input with
    | ValidDate dt -> printfn $"{dt}"
    | _ -> printfn $"'{input}' is not a valid date"

parse "2019-12-20"
parse "Hello"

// Parameterized Partial Active Patterns

let calculateOld i =
    if i % 3 = 0 && i % 5 = 0 then "FizzBuzz"
    elif i % 3 = 0 then "Fizz"
    elif i % 5 = 0 then "Buzz"
    else i |> string

let calculateOld2 i =
    match i % 3, i % 5 with
    | 0, 0 -> "FizzBuzz"
    | 0, _ -> "Fizz"
    | _, 0 -> "Buzz"
    | _ -> i |> string

let (|IsDivisibleWithList|_|) divisors n =
    if divisors |> List.forall (fun div -> n % div = 0) then Some() else None

let calculateWithDivisors i =
    match i with
    | IsDivisibleWithList [ 3; 5; 7 ] -> "FizzBuzzBazz"
    | IsDivisibleWithList [ 3; 5 ] -> "FizzBuzz"
    | IsDivisibleWithList [ 3; 7 ] -> "FizzBazz"
    | IsDivisibleWithList [ 5; 7 ] -> "BuzzBazz"
    | IsDivisibleWithList [ 3 ] -> "Fizz"
    | IsDivisibleWithList [ 5 ] -> "Buzz"
    | IsDivisibleWithList [ 7 ] -> "Bazz"
    | _ -> i |> string

let (|IsDivisibleBy|_|) divisor n =
    if n % divisor = 0 then Some() else None

let (|NotDivisibleBy|_|) divisor n =
    if n % divisor <> 0 then Some() else None

// multi-case active pattern:
// let (|IsDivisibleBy|NotDivisibleBy|) divisor n =
//     if n % divisor = 0 then IsDivisibleBy else NotDivisibleBy
//
// let isDivisibleBy divisor year =
//     year % divisor = 0
// let notDivisibleBy divisor year =
//     not (year |> isDivisibleBy divisor)
//
// let isLeapYear year =
//     year |> isDivisibleBy 400 || (year |> isDivisibleBy 4 && year |> notDivisibleBy 100)
//
// let isLeapYear input =
//     match input with
//     | year when year |> isDivisibleBy 400 -> true
//     | year when year |> isDivisibleBy 4 && year |> isDivisibleBy 100 |> not -> true
//     | _ -> false

let isLeapYear year =
    match year with
    | IsDivisibleBy 400 -> true
    | IsDivisibleBy 4 & NotDivisibleBy 100 -> true
    | _ -> false

let calculateWithIfs i =
    match i with
    | IsDivisibleBy 3 & IsDivisibleBy 5 & IsDivisibleBy 7 -> "FizzBuzzBazz"
    | IsDivisibleBy 3 & IsDivisibleBy 5 -> "FizzBuzz"
    | IsDivisibleBy 3 & IsDivisibleBy 7 -> "FizzBazz"
    | IsDivisibleBy 5 & IsDivisibleBy 7 -> "BuzzBazz"
    | IsDivisibleBy 3 -> "Fizz"
    | IsDivisibleBy 5 -> "Buzz"
    | IsDivisibleBy 7 -> "Bazz"
    | i -> i |> string


// The List.reduce function will concatenate all of the strings generated by the List.map function.
// The last line is to cater for numbers that are not divisible by any of the numbers in the initial list.
let calculate mapping n =
    mapping
    |> List.map (fun (divisor, result) -> if n % divisor = 0 then result else "")
    |> List.reduce (+) // (+) is a shortcut for (fun acc v -> acc + v)
    |> fun input -> if input = "" then string n else input


[ 1..15 ]
|> List.map (calculate [ (3, "Fizz"); (5, "Buzz") ])
|> List.iter (fun x -> printfn $"{x}")

// Multi-Case Active Patterns
// Multi-Case Active Patterns are different from Partial Active Patterns in that they always return one of the possible values rather than an option type.

type Rank =
    | Ace
    | Two
    | Three
    | Four
    | Five
    | Six
    | Seven
    | Eight
    | Nine
    | Ten
    | Jack
    | Queen
    | King

type Suit =
    | Hearts
    | Clubs
    | Diamonds
    | Spades

type Card = Rank * Suit

let (|Red|Black|) (card: Card) =
    match card with
    | _, Diamonds
    | _, Hearts -> Red
    | _, Clubs
    | _, Spades -> Black

let describeColour card =
    match card with
    | Red -> "red"
    | Black -> "black"
    |> fun x -> printfn $"The card is {x}"

describeColour (Two, Hearts)

// Single case active patterns
// The last type of active pattern that we will look at is the single-case.
// The purpose of the single-case is to allow you to decompose an input in different ways.

let (|CharacterCount|) (input: string) = input.Length

let (|ContainsANumber|) (input: string) =
    input |> Seq.filter Char.IsDigit |> Seq.length > 0

let (|IsValidPassword|) input =
    match input with
    | CharacterCount len when len < 8 -> (false, "Password must be at least 8 characters.")
    | ContainsANumber false -> (false, "Password must contain at least 1 digit.")
    | _ -> (true, "")

let setPassword input =
    match input with
    | IsValidPassword(true, _) as pwd -> Ok pwd
    | IsValidPassword(false, failureReason) -> Error $"Password not set: {failureReason}"

let badPassword = setPassword "password"

match badPassword with
| Ok pwd -> printfn $"{pwd}"
| Error ex -> printfn $"{ex}"

let goodPassword = setPassword "passw0rd"

match goodPassword with
| Ok pwd -> printfn $"{pwd}"
| Error ex -> printfn $"{ex}"

// (0, 0) (0, 0) = 400 // 300 + 100 + (0 * 15) + (0 * 20)
// (3, 2) (3, 2) = 485 // 300 + 100 + (3 * 15) + (2 * 20)
// (5, 1) (4, 3) = 180 // 0 + 100 + (4 * 15) + (1 * 20)
// (2, 1) (0, 7) = 20 // 0 + 0 + (0 * 15) + (1 * 20) (2, 2) (3, 3) = 170
// 0 + 100 + (2 * 15) + (2 * 20)

type Score = int * int

let (|CorrectScore|_|) (expected: Score, actual: Score) =
    if expected = actual then Some() else None

let (|Draw|HomeWin|AwayWin|) (score: Score) =
    match score with
    | h, a when h = a -> Draw
    | h, a when h > a -> HomeWin
    | _ -> AwayWin

let (|CorrectResult|_|) (expected: Score, actual: Score) =
    match expected, actual with
    | Draw, Draw -> Some()
    | HomeWin, HomeWin -> Some()
    | AwayWin, AwayWin -> Some()
    | _ -> None

let goalScore (expected: Score) (actual: Score) =
    let home = min (fst expected) (fst actual)
    let away = min (snd expected) (snd actual)
    (home * 15) + (away * 20)

let resultScore (expected: Score) (actual: Score) =
    match (expected, actual) with
    | CorrectScore -> 300
    | CorrectResult -> 100
    | _ -> 0

let calculatePoints (expected: Score) (actual: Score) =
    [ resultScore; goalScore ] |> List.sumBy (fun f -> f expected actual)

let assertNoScoreDrawCorrect =
    calculatePoints (0, 0) (0, 0) = 400 |> fun x -> printfn $"{x}"

let assertHomeWinExactMatch =
    calculatePoints (3, 2) (3, 2) = 485 |> fun x -> printfn $"{x}"

let assertHomeWin = calculatePoints (5, 1) (4, 3) = 180 |> fun x -> printfn $"{x}"

let assertIncorrect = calculatePoints (2, 1) (0, 7) = 20 |> fun x -> printfn $"{x}"

let assertDraw = calculatePoints (2, 2) (3, 3) = 170 |> fun x -> printfn $"{x}"
